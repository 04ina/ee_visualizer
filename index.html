
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PostgreSQL Path Tree + Best Plan</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: 'Courier New', monospace;
    }
    #main-container {
      display: flex;
      height: 100vh;
      width: 100vw;
    }
    #tree-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      min-width: 300px;
    }
    #cy {
      width: 100%;
      height: 100%;
      background-color: #fafafa;
    }
    #vertical-resizer {
      width: 6px;
      background: #ccc;
      cursor: col-resize;
      user-select: none;
    }
    #right-container {
      display: flex;
      flex-direction: column;
      width: 50%;
      min-width: 300px;
    }
    #explain-split-container {
      display: flex;
      flex: none;
      height: 40vh;
      border-bottom: 1px solid #ddd;
    }
    #explain-best-container {
      flex: 1;
      padding: 10px;
      background: #f8f8f8;
      overflow: auto;
      border-right: 1px solid #ddd;
      font-size: 13px;
      line-height: 1.4;
      white-space: pre-wrap;
      cursor: pointer;
    }
    #explain-vertical-resizer {
      width: 6px;
      background: #ccc;
      cursor: col-resize;
      user-select: none;
    }
    #explain-selected-container {
      flex: 1;
      padding: 10px;
      background: #f0f8f8;
      overflow: auto;
      font-size: 13px;
      line-height: 1.4;
      white-space: pre-wrap;
      cursor: pointer;
    }
    #explain-best-container .path-line,
    #explain-selected-container .path-line {
      padding: 2px 0;
    }
    #explain-best-container .path-line:hover,
    #explain-selected-container .path-line:hover {
      background: #e0e0e0;
    }
    #explain-best-container .selected,
    #explain-selected-container .selected {
      background-color: #cce6ff !important;
    }
    #explain-best-container .child-highlight,
    #explain-selected-container .child-highlight {
      background-color: #e3f3fd !important;
    }
    #explain-best-container .section-header,
    #explain-selected-container .section-header {
      font-weight: bold;
      margin-top: 10px;
      margin-bottom: 5px;
      padding: 5px;
      background-color: #e6f3ff;
      border-left: 3px solid #0066cc;
    }
    #horizontal-resizer {
      height: 6px;
      background: #ccc;
      cursor: row-resize;
      user-select: none;
      flex: none;
    }
    #empty-container {
      flex: 1;
      background: #f0f0f0;
      overflow: hidden;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }

    #table-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .table-control-btn {
      padding: 6px 12px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }

    .table-control-btn.active {
      background: #007bff;
      color: white;
      border-color: #007bff;
    }

    .table-control-btn:hover:not(.active) {
      background: #f5f5f5;
    }

    #table-container {
      flex: 1;
      overflow: auto;
      margin-top: 10px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-family: Arial, sans-serif;
      font-size: 12px;
      table-layout: auto;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 6px 8px;
      text-align: left;
      white-space: nowrap;
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    th {
      background-color: #eee;
      position: sticky;
      top: 0;
      cursor: pointer;
    }
    #table-wrapper {
      overflow-x: auto;
      width: 100%;
      height: 100%;
    }
    th.sort-asc::after {
      content: ' ‚Üë';
      color: #000;
    }
    th.sort-desc::after {
      content: ' ‚Üì';
      color: #000;
    }
    .control-button {
      position: absolute;
      left: 10px;
      z-index: 10;
      padding: 6px 12px;
      font-size: 14px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .control-button:hover {
      background: #f5f5f5;
    }
    #copy-selected-path { top: 10px; }
    #reset-view { top: 50px; }
    #collapse-all { top: 90px; }
    #expand-best { top: 130px; }
    #clear-filters { top: 170px; }
    #toggle-layout { top: 210px; }
    .highlighted {
      background-color: #ffcc00 !important;
      border-color: #ff9900 !important;
      border-width: 2px !important;
    }
    .selected-row {
      background-color: #cce6ff !important;
    }
    .corresponding-relation-highlight {
      background-color: #cce6ff !important;
    }

    .best-path-row {
      border: 2px solid #0066cc !important;
    }
    input[type="checkbox"].indeterminate::after {
      content: "-";
      display: block;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 2px;
      background-color: currentColor;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="main-container">
    <div id="tree-container">
      <div id="cy"></div>
      <button id="copy-selected-path" class="control-button">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø—É—Ç—å</button>
      <button id="reset-view" class="control-button">–°–±—Ä–æ—Å–∏—Ç—å –≤–∏–¥</button>
      <button id="collapse-all" class="control-button">–°–≤–µ—Ä–Ω—É—Ç—å –¥–µ—Ä–µ–≤–æ</button>
      <button id="expand-best" class="control-button">–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å –ª—É—á—à–∏–π –ø–ª–∞–Ω</button>
      <button id="clear-filters" class="control-button">–°–±—Ä–æ—Å–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã</button>
      <button id="toggle-layout" class="control-button">–ü–æ–≤–µ—Ä–Ω—É—Ç—å layout</button>
    </div>
    <div id="vertical-resizer"></div>
    <div id="right-container">
      <div id="explain-split-container">
        <div id="explain-best-container">–õ—É—á—à–∏–π –ø–ª–∞–Ω (EXPLAIN)</div>
        <div id="explain-vertical-resizer"></div>
        <div id="explain-selected-container">–í—ã–±—Ä–∞–Ω–Ω—ã–π –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å (—Å –¥–æ—á–µ—Ä–Ω–∏–º–∏ —É–∑–ª–∞–º–∏)</div>
      </div>
      <div id="horizontal-resizer"></div>
      <div id="empty-container">–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ —Å—Ç—Ä–æ–∫—É –≤ EXPLAIN, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø—É—Ç–∏.</div>
    </div>
  </div>

  <script src="dagre.min.js"></script>
  <script src="cytoscape.min.js"></script>
  <script src="cytoscape-dagre.min.js"></script>

  <script>
    let cy, nodeMap, subqueryNodes, levelNodes, relationNodes, levelOrder, expanded, relationFilters;
    let allBestRoots = [];
    let bestRelKeys = new Set();
    let currentSelectedPathId = null;
    let bestPathIds = new Set();
    let bestSubqueryIds = new Set();
    let currentLayoutDirection = 'LR';

    function isPathVisible(pathIdStr) {
      const path = nodeMap.get(pathIdStr);
      if (!path) return false;
      return expanded.has(`subquery-${path._subKey}`) &&
             expanded.has(`level-${path._levelKey}`) &&
             expanded.has(`relation-${path._relKey}`);
    }

    function buildElements() {
      const nodes = [];
      const edges = [];

      for (const item of subqueryNodes) {
        if (!item.id) continue;
        nodes.push({
          group: 'nodes',
          data: {
            id: item.id,
            label: item.label
          },
          classes: 'subquery-group'
        });
      }

      for (const item of subqueryNodes) {
        const subId = item.id;
        if (!expanded.has(subId)) continue;

        for (const levelItem of levelNodes.values()) {
          const parts = levelItem.id.split('-');
          if (parts.length < 3 || parts[0] !== 'level') continue;
          const subqueryPart = parts[1];
          if (`subquery-${subqueryPart}` !== subId) continue;

          nodes.push({
            group: 'nodes',
            data: {
              id: levelItem.id,
              label: levelItem.label,
              parent: subId
            },
            classes: 'level-group'
          });

          if (!expanded.has(levelItem.id)) continue;

          // –°–æ–±–µ—Ä—ë–º –æ—Ç–Ω–æ—à–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
          const levelRels = [];
          for (const relItem of relationNodes.values()) {
            const relParts = relItem.id.split('-');
            if (relParts.length < 4 || relParts[0] !== 'relation') continue;
            const relSub = relParts[1];
            const relLevel = relParts[2];
            const expectedLevelId = `level-${relSub}-${relLevel}`;
            if (expectedLevelId !== levelItem.id) continue;
            levelRels.push(relItem);
          }

          if (levelRels.length === 0) continue;

          // –†–∞–∑–¥–µ–ª–∏–º –Ω–∞ best –∏ other
          const bestRels = levelRels.filter(rel => bestRelKeys.has(rel.id.replace('relation-', '')));
          const otherRels = levelRels.filter(rel => !bestRelKeys.has(rel.id.replace('relation-', '')));

          // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –ª—É—á—à–∏—Ö –æ—Ç–Ω–æ—à–µ–Ω–∏–π
          if (bestRels.length > 0) {
            const bestGroup = `best-rels-${levelItem.id}`;
            nodes.push({
              group: 'nodes',
              data: { id: bestGroup, label: 'Best rel', parent: levelItem.id },
              classes: 'relation-group best-group'
            });

            if (expanded.has(bestGroup)) {
              for (const relItem of bestRels) {
                nodes.push({
                  group: 'nodes',
                  data: { id: relItem.id, label: relItem.label, parent: bestGroup },
                  classes: 'relation-group'
                });

                if (expanded.has(relItem.id)) {
                  const relKey = relItem.id.replace('relation-', '');
                  const currentFilter = relationFilters.get(relItem.id) || '';

                  // –í—Å–µ –ø—É—Ç–∏ –≤ —ç—Ç–æ–º –æ—Ç–Ω–æ—à–µ–Ω–∏–∏
                  const relPaths = [];
                  for (const [pathIdStr, path] of nodeMap.entries()) {
                    if (path._relKey !== relKey) continue;
                    if (currentFilter && path.path_type.toLowerCase().indexOf(currentFilter.toLowerCase()) === -1) continue;
                    relPaths.push({ id: pathIdStr, path });
                  }

                  if (relPaths.length === 0) continue;

                  // –†–∞–∑–¥–µ–ª—è–µ–º –Ω–∞ best –∏ other
                  const bestPaths = relPaths.filter(p => bestPathIds.has(p.id));
                  const otherPaths = relPaths.filter(p => !bestPathIds.has(p.id));

                  // –ì—Ä—É–ø–ø–∞ –ª—É—á—à–∏—Ö –ø—É—Ç–µ–π
                  if (bestPaths.length > 0) {
                    const bestGroup = `best-paths-${relItem.id}`;
                    nodes.push({
                      group: 'nodes',
                      data: { id: bestGroup, label: `Best paths (${bestPaths.length})`, parent: relItem.id },
                      classes: 'path-group best-paths-group'
                    });

                    if (expanded.has(bestGroup)) {
                      for (const { id, path } of bestPaths) {
                        let label = `${path.path_type}\n(id:${path.path_id})`;
                        if (path.startup_cost !== undefined && path.total_cost !== undefined) {
                          label += `\ncost: ${path.startup_cost.toFixed(2)}..${path.total_cost.toFixed(2)}`;
                        }
                        if (path.rows !== undefined) {
                          label += `\nrows: ${Math.round(path.rows)}`;
                        }
                        nodes.push({
                          group: 'nodes',
                          data: { id, label, parent: bestGroup },
                          classes: 'path-node best-path-node'
                        });
                      }
                    }
                  }

                  // –ì—Ä—É–ø–ø–∞ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –ø—É—Ç–µ–π
                  if (otherPaths.length > 0) {
                    const otherGroup = `other-paths-${relItem.id}`;
                    nodes.push({
                      group: 'nodes',
                      data: { id: otherGroup, label: `Other paths (${otherPaths.length})`, parent: relItem.id },
                      classes: 'path-group other-paths-group'
                    });

                    if (expanded.has(otherGroup)) {
                      for (const { id, path } of otherPaths) {
                        let label = `${path.path_type}\n(id:${path.path_id})`;
                        if (path.startup_cost !== undefined && path.total_cost !== undefined) {
                          label += `\ncost: ${path.startup_cost.toFixed(2)}..${path.total_cost.toFixed(2)}`;
                        }
                        if (path.rows !== undefined) {
                          label += `\nrows: ${Math.round(path.rows)}`;
                        }
                        nodes.push({
                          group: 'nodes',
                          data: { id, label, parent: otherGroup },
                          classes: 'path-node'
                        });
                      }
                    }
                  }
                }
              }
            }
          }

          // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –æ—Ç–Ω–æ—à–µ–Ω–∏–π
          if (otherRels.length > 0) {
            const otherGroup = `other-rels-${levelItem.id}`;
            nodes.push({
              group: 'nodes',
              data: { id: otherGroup, label: `Other rels (${otherRels.length})`, parent: levelItem.id },
              classes: 'relation-group other-group'
            });

            if (expanded.has(otherGroup)) {
              for (const relItem of otherRels) {
                nodes.push({
                  group: 'nodes',
                  data: { id: relItem.id, label: relItem.label, parent: otherGroup },
                  classes: 'relation-group'
                });

                if (expanded.has(relItem.id)) {
                  const currentFilter = relationFilters.get(relItem.id) || '';
                  for (const [pathIdStr, path] of nodeMap.entries()) {
                    if (path._relKey !== relItem.id.replace('relation-', '')) continue;
                    if (currentFilter && path.path_type.toLowerCase().indexOf(currentFilter.toLowerCase()) === -1) continue;

                    let label = `${path.path_type}\n(id:${path.path_id})`;
                    if (path.startup_cost !== undefined && path.total_cost !== undefined) {
                      label += `\ncost: ${path.startup_cost.toFixed(2)}..${path.total_cost.toFixed(2)}`;
                    }
                    if (path.rows !== undefined) {
                      label += `\nrows: ${Math.round(path.rows)}`;
                    }

                    nodes.push({
                      group: 'nodes',
                      data: { id: pathIdStr, label: label, parent: relItem.id },
                      classes: 'path-node'
                    });
                  }
                }
              }
            }
          }
        }
      }

      for (const [subKey, levelsSet] of levelOrder) {
        const levels = Array.from(levelsSet).sort((a, b) => a - b);
        for (let i = 0; i < levels.length - 1; i++) {
          const curId = `level-${subKey}-L${levels[i]}`;
          const nextId = `level-${subKey}-L${levels[i + 1]}`;
          if (expanded.has(curId) && expanded.has(nextId)) {
            edges.push({
              group: 'edges',
              data: {
                id: `edge-level-${curId}-${nextId}`,
                source: curId,
                target: nextId
              },
              classes: 'level-order-edge'
            });
          }
        }
      }

      // –°–æ–±–∏—Ä–∞–µ–º ID –≤—Å–µ—Ö –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö —É–∑–ª–æ–≤ (–≤–∫–ª—é—á–∞—è –ø—É—Ç–∏)
      const addedNodeIds = new Set();
      nodes.forEach(node => {
        if (node.data && node.data.id) {
          addedNodeIds.add(node.data.id);
        }
      });

      // –°—Ç—Ä–æ–∏–º —Ä–µ–±—Ä–∞ —Ç–æ–ª—å–∫–æ –º–µ–∂–¥—É —Ä–µ–∞–ª—å–Ω–æ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ —É–∑–ª–∞–º–∏
      for (const [srcId, path] of nodeMap.entries()) {
        if (!addedNodeIds.has(srcId) || !Array.isArray(path.child_paths)) continue;
        for (const childId of path.child_paths) {
          const childIdStr = String(childId);
          if (addedNodeIds.has(childIdStr)) {
            edges.push({
              group: 'edges',
              data: {
                id: `edge-path-${srcId}-${childIdStr}`,
                source: srcId,
                target: childIdStr
              }
            });
          }
        }
      }

      return [...nodes, ...edges];
    }


    function refreshGraph() {
      const elements = buildElements();
      cy.json({ elements });
      cy.layout({
        name: 'dagre',
        rankDir: currentLayoutDirection, // TB LR
        nodeSep: 40,
        edgeSep: 40,
        rankSep: currentLayoutDirection === 'LR' ? 70 : 40,
        animate: true,
        animationDuration: 300,
        fit: true
      }).run();

      if (currentSelectedPathId) {
        cy.elements('.selected-in-tree').removeClass('selected-in-tree');
        // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –∑–∞–Ω–æ–≤–æ
        const path = nodeMap.get(currentSelectedPathId);
        if (path) {
          const idsToTry = [
            currentSelectedPathId,
            `relation-${path._relKey}`,
            `level-${path._levelKey}`,
            `subquery-${path._subKey}`
          ];
          for (const id of idsToTry) {
            const el = cy.getElementById(id);
            if (el.length > 0) {
              el.addClass('selected-in-tree');
              break;
            }
          }
        }
      }
    }

    function findAllBestPlans() {
      allBestRoots = [];
      bestRelKeys.clear();
      bestPathIds.clear();
      bestSubqueryIds.clear();

      const mainCandidateRoots = [];
      for (const path of nodeMap.values()) {
        if (path.subquery_level === 1 && path.level === 0) {
          mainCandidateRoots.push(path);
        }
      }

      if (mainCandidateRoots.length === 0) {
        console.warn('–ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø—É—Ç–µ–π —Å subquery_level=1 –∏ level=0');
        return;
      }

      const mainBestRoot = mainCandidateRoots.reduce((a, b) => {
        const aRelId = a.rel_id ?? -Infinity;
        const bRelId = b.rel_id ?? -Infinity;

        if (aRelId !== bRelId) {
          return aRelId > bRelId ? a : b;
        }

        return a.total_cost < b.total_cost ? a : b;
      });

      function collectPathTree(p) {
        bestPathIds.add(String(p.path_id));
        bestRelKeys.add(p._relKey);
        bestSubqueryIds.add(p.subquery_id);

        if (Array.isArray(p.child_paths)) {
          for (const childId of p.child_paths) {
            const child = nodeMap.get(String(childId));
            if (child) collectPathTree(child);
          }
        }
      }

      collectPathTree(mainBestRoot);
      allBestRoots = [mainBestRoot];

      const unincludedSubqueries = getUnincludedSubqueries();
      for (const root of unincludedSubqueries) {
        function collectIndependentPathTree(p) {
          if (!bestPathIds.has(String(p.path_id))) {
            bestPathIds.add(String(p.path_id));
            bestRelKeys.add(p._relKey);
            bestSubqueryIds.add(p.subquery_id);
          }

          if (Array.isArray(p.child_paths)) {
            for (const childId of p.child_paths) {
              const child = nodeMap.get(String(childId));
              if (child) collectIndependentPathTree(child);
            }
          }
        }

        collectIndependentPathTree(root);
      }
    }

    function getAllSubqueryIds() {
      const allSubqueryIds = new Set();
      for (const path of nodeMap.values()) {
        allSubqueryIds.add(path.subquery_id);
      }
      return allSubqueryIds;
    }

    function getUnincludedSubqueries() {
      const allSubqueryIds = getAllSubqueryIds();
      const unincludedSubqueries = [];

      const referencedSubqueryIds = new Set();
      for (const pathId of bestPathIds) {
        const path = nodeMap.get(pathId);
        if (path && Array.isArray(path.child_paths)) {
          for (const childId of path.child_paths) {
            const child = nodeMap.get(String(childId));
            if (child && child.subquery_id !== path.subquery_id) {
              referencedSubqueryIds.add(child.subquery_id);
            }
          }
        }
      }

      for (const subqueryId of allSubqueryIds) {
        const isMainQuery = Array.from(allBestRoots).some(root => root.subquery_id == subqueryId);
        if (!isMainQuery && !referencedSubqueryIds.has(subqueryId)) {
          for (const path of nodeMap.values()) {
            if (path.subquery_id == subqueryId && path.level === 0) {
              unincludedSubqueries.push(path);
              break;
            }
          }
        }
      }

      return unincludedSubqueries;
    }

    function renderAllBestPlans() {
      if (allBestRoots.length === 0) {
        document.getElementById('explain-best-container').textContent = "–õ—É—á—à–∏–µ –ø–ª–∞–Ω—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.";
        return;
      }

      const lines = [];

      if (allBestRoots.length > 0) {
        lines.push({ text: "–û—Å–Ω–æ–≤–Ω–æ–π –ø–ª–∞–Ω", pathId: null });

        allBestRoots.forEach((root, idx) => {
          if (idx > 0) lines.push({ text: "", pathId: null });

          const collectLines = (path, depth) => {
            const idStr = String(path.path_id);
            const indent = "  ".repeat(depth);

            let line = `${indent}-> ${path.path_type}`;
            if (path.rel_name) {
              if (path.rel_alias && path.rel_alias !== path.rel_name) {
                line += ` on ${path.rel_name} ${path.rel_alias}`;
              } else {
                line += ` on ${path.rel_name}`;
              }
            }
            if (path.total_cost !== undefined) {
              line += `  (cost=${path.startup_cost.toFixed(2)}..${path.total_cost.toFixed(2)} rows=${Math.round(path.rows)} width=${path.width})`;
            }
            lines.push({ text: line, pathId: idStr });

            if (Array.isArray(path.child_paths)) {
              for (const childId of path.child_paths) {
                const child = nodeMap.get(String(childId));
                if (child) {
                  collectLines(child, depth + 1);
                }
              }
            }
          };

          collectLines(root, 0);
        });
      }

      const unincludedSubqueries = getUnincludedSubqueries();
      if (unincludedSubqueries.length > 0) {
        if (lines.length > 0) lines.push({ text: "", pathId: null });
        lines.push({ text: "CTEs", pathId: null });

        unincludedSubqueries.forEach((root, idx) => {
          if (idx > 0) lines.push({ text: "", pathId: null });

          const collectLines = (path, depth) => {
            const idStr = String(path.path_id);
            const indent = "  ".repeat(depth);

            let line = `${indent}-> ${path.path_type}`;
            if (path.rel_name) {
              if (path.rel_alias && path.rel_alias !== path.rel_name) {
                line += ` on ${path.rel_name} ${path.rel_alias}`;
              } else {
                line += ` on ${path.rel_name}`;
              }
            }
            if (path.total_cost !== undefined) {
              line += `  (cost=${path.startup_cost.toFixed(2)}..${path.total_cost.toFixed(2)} rows=${Math.round(path.rows)} width=${path.width})`;
            }
            lines.push({ text: line, pathId: idStr });

            if (Array.isArray(path.child_paths)) {
              for (const childId of path.child_paths) {
                const child = nodeMap.get(String(childId));
                if (child) {
                  collectLines(child, depth + 1);
                }
              }
            }
          };

          collectLines(root, 0);
        });
      }

      const explainBestContainer = document.getElementById('explain-best-container');
      explainBestContainer.innerHTML = lines.map(({ text, pathId }) => {
        if (pathId) {
          return `<div class="path-line" data-path-id="${pathId}">${text}</div>`;
        }
        return `<div class="section-header">${text}</div>`;
      }).join('');

      explainBestContainer.querySelectorAll('.path-line').forEach(el => {
        el.addEventListener('click', () => {
          document.querySelectorAll('.path-line.selected').forEach(e => e.classList.remove('selected'));
          document.querySelectorAll('.path-line.child-highlight').forEach(e => e.classList.remove('child-highlight'));
          document.querySelectorAll('.selected-row').forEach(e => e.classList.remove('selected-row'));
          cy.elements('.selected-in-tree').removeClass('selected-in-tree');

          el.classList.add('selected');
          const pathId = el.getAttribute('data-path-id');
          currentSelectedPathId = pathId;

          highlightChildNodesInExplain(pathId);

          // Check the current table type and update accordingly
          if (currentTableType === 'relations') {
            // Stay on relations table but update with new clicked path context
            showRelationsTable(pathId);
            // Highlight the corresponding relation
            highlightCorrespondingRelation(pathId);
          } else {
            // For alternative paths table, behave as before
            showAlternativePaths(pathId);
          }

          highlightPathInTree(pathId);

          // Also render the selected path with its children in the right panel
          renderSelectedPathWithChildren(pathId);
        });

        el.addEventListener('dblclick', () => {
          const pathId = el.getAttribute('data-path-id');
          if (pathId) {
            const node = cy.getElementById(pathId);
            if (node && node.length > 0) {
              cy.animate({
                center: {
                  eles: node
                },
                zoom: 1.2,
                duration: 500
              });
            } else {
              const path = nodeMap.get(pathId);
              if (path) {
                const idsToTry = [
                  `relation-${path._relKey}`,
                  `level-${path._levelKey}`,
                  `subquery-${path._subKey}`
                ];

                for (const id of idsToTry) {
                  const containerNode = cy.getElementById(id);
                  if (containerNode && containerNode.length > 0) {
                    cy.animate({
                      center: {
                        eles: containerNode
                      },
                      zoom: 1.2,
                      duration: 500
                    });
                    break;
                  }
                }
              }
            }
          }
        });
      });
    }

    // –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Å—Ç–æ–ª–±—Ü–æ–≤ (—Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –º–µ–∂–¥—É –≤—ã–∑–æ–≤–∞–º–∏)
    let globalVisibleColumns = null;

    function renderGroupedColumns(allColumns, visibleColumns) {
      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≥—Ä—É–ø–ø—ã —Å—Ç–æ–ª–±—Ü–æ–≤
      const columnGroups = {
        "–ò–µ—Ä–∞—Ä—Ö–∏—è –∏ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã": ["query_id", "subquery_id", "subquery_level", "level", "rel_id", "path_id", "child_paths"],
        "–û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏": ["startup_cost", "total_cost", "rows", "width"],
        "–†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–±–æ—Ç—ã add_path": ["add_path_result", "displaced_by", "cost_cmp", "fuzz_factor", "pathkeys_cmp", "bms_cmp", "rows_cmp", "parallel_safe_cmp"],
        "–î—Ä—É–≥–∏–µ": []
      };

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–∏–µ —Å—Ç–æ–ª–±—Ü—ã –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –≥—Ä—É–ø–ø–∞–º
      const groupedColumns = new Set();
      for (const group of Object.values(columnGroups)) {
        for (const col of group) {
          groupedColumns.add(col);
        }
      }

      // –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–æ–ª–±—Ü—ã –¥–æ–±–∞–≤–ª—è–µ–º –≤ "–î—Ä—É–≥–∏–µ"
      for (const col of allColumns) {
        if (!groupedColumns.has(col)) {
          columnGroups["–î—Ä—É–≥–∏–µ"].push(col);
        }
      }

      let html = '';
      for (const [groupName, groupColumns] of Object.entries(columnGroups)) {
        if (groupColumns.length === 0) continue;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—Å–µ –ª–∏ —Å—Ç–æ–ª–±—Ü—ã –≤ –≥—Ä—É–ø–ø–µ –≤–∏–¥–∏–º—ã
        const allVisible = groupColumns.every(col => visibleColumns.has(col));
        const someVisible = groupColumns.some(col => visibleColumns.has(col));

        html += `
          <div style="padding: 4px 6px; border-bottom: 1px solid #eee;">
            <label style="display: flex; align-items: center; padding: 4px 6px; cursor: pointer; white-space: nowrap; gap: 6px;">
              <input type="checkbox" class="group-checkbox" data-group="${groupName}" ${allVisible ? 'checked' : ''}>
              <strong>${groupName}</strong>
            </label>
            <div style="margin-left: 20px;">
        `;

        for (const col of groupColumns) {
          html += `
            <label style="display: flex; align-items: center; padding: 2px 6px; cursor: pointer; white-space: nowrap; gap: 6px;">
              <input type="checkbox" class="column-checkbox" data-column="${col}" data-group="${groupName}" ${visibleColumns.has(col) ? 'checked' : ''}>
              ${col}
            </label>
          `;
        }

        html += `
            </div>
          </div>
        `;
      }

      return html;
    }

    function setGroupIndeterminateStates(dropdown) {
      dropdown.querySelectorAll('input[type="checkbox"].group-checkbox').forEach(checkbox => {
        const groupName = checkbox.getAttribute('data-group');
        const groupColumns = Array.from(dropdown.querySelectorAll(`input[data-group="${groupName}"].column-checkbox`));
        const checkedCount = groupColumns.filter(checkbox => checkbox.checked).length;

        if (checkedCount > 0 && checkedCount < groupColumns.length) {
          checkbox.indeterminate = true;
        } else {
          checkbox.indeterminate = false;
        }
      });
    }

    // Current active table type
    let currentTableType = 'alternative-paths'; // 'alternative-paths', 'relations'

    function showAlternativePaths(clickedPathId) {
      const clickedPath = nodeMap.get(clickedPathId);
      if (!clickedPath) return;

      const relKey = clickedPath._relKey;
      const alternatives = Array.from(nodeMap.values()).filter(p => p._relKey === relKey);

      const container = document.getElementById('empty-container');
      if (alternatives.length === 0) {
        container.innerHTML = '–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø—É—Ç–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.';
        return;
      }

      const COLUMN_ORDER = [
        "query_id", "subquery_id", "subquery_level", "rel_id", "path_id",
        "path_type", "rel_name", "rel_alias", "indexoid", "level",
        "child_paths", "startup_cost", "total_cost", "rows", "width",
        "add_path_result", "displaced_by", "cost_cmp", "fuzz_factor",
        "pathkeys_cmp", "bms_cmp", "rows_cmp", "parallel_safe_cmp"
      ];

      const allKeys = new Set();
      for (const p of alternatives) {
        for (const key in p) {
          if (!key.startsWith('_')) {
            allKeys.add(key);
          }
        }
      }

      const orderedColumns = COLUMN_ORDER.filter(col => allKeys.has(col));
      const extraKeys = Array.from(allKeys).filter(k => !COLUMN_ORDER.includes(k));
      const allColumns = [...orderedColumns, ...extraKeys];

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–¥–∏–Ω —Ä–∞–∑
      if (globalVisibleColumns === null) {
        globalVisibleColumns = new Set(allColumns);
      } else {
        // –£–¥–∞–ª—è–µ–º —Å—Ç–æ–ª–±—Ü—ã, –∫–æ—Ç–æ—Ä—ã—Ö –±–æ–ª—å—à–µ –Ω–µ—Ç –≤ —Ç–µ–∫—É—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        for (const col of Array.from(globalVisibleColumns)) {
          if (!allColumns.includes(col)) {
            globalVisibleColumns.delete(col);
          }
        }
      }
      const visibleColumns = globalVisibleColumns;

      // –£–¥–∞–ª—è–µ–º —Å—Ç–æ–ª–±—Ü—ã, –∫–æ—Ç–æ—Ä—ã—Ö –±–æ–ª—å—à–µ –Ω–µ—Ç –≤ –¥–∞–Ω–Ω—ã—Ö
      for (const col of Array.from(visibleColumns)) { // ‚Üê –≤–∞–∂–Ω–æ: Array.from, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–∫–∏ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏
        if (!allColumns.includes(col)) {
          visibleColumns.delete(col);
        }
      }

      // –§–æ—Ä–º–∏—Ä—É–µ–º HTML
      let controlsHTML = `
        <div id="table-controls">
          <button class="table-control-btn ${currentTableType === 'alternative-paths' ? 'active' : ''}" data-table-type="alternative-paths">–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø—É—Ç–∏</button>
          <button class="table-control-btn ${currentTableType === 'relations' ? 'active' : ''}" data-table-type="relations">–û—Ç–Ω–æ—à–µ–Ω–∏—è</button>
        </div>
        <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap; margin-top:10px;">
          <input type="text" id="table-search" placeholder="üîç –ü–æ–∏—Å–∫ –≤ —Ç–∞–±–ª–∏—Ü–µ..."
                style="flex:1; min-width:150px; padding:6px 10px; border:1px solid #ccc; border-radius:3px; font-size:13px;">
          <div style="position:relative; display:inline-block;">
            <button id="toggle-columns-btn" type="button"
                    style="padding:6px 10px; border:1px solid #ccc; background:#fff; border-radius:3px; cursor:pointer; font-size:13px;">
              ‚öôÔ∏è –°—Ç–æ–ª–±—Ü—ã
            </button>
            <div id="columns-dropdown" style="display:none; position:absolute; top:100%; right:0; background:#fff; border:1px solid #ccc; border-radius:3px; z-index:1000; max-height:300px; overflow-y:auto; box-shadow:0 2px 6px rgba(0,0,0,0.2);">
              ${renderGroupedColumns(allColumns, visibleColumns)}
            </div>
          </div>
        </div>
      `;

      let tableHTML = `<div id="table-wrapper" style="max-height:100%; overflow:auto;"><table><thead><tr>`;

      // –¢–æ–ª—å–∫–æ –≤–∏–¥–∏–º—ã–µ —Å—Ç–æ–ª–±—Ü—ã
      const displayedColumns = allColumns.filter(col => visibleColumns.has(col));
      displayedColumns.forEach(col => {
        tableHTML += `<th data-column="${col}">${col}</th>`;
      });
      tableHTML += '</tr></thead><tbody>';

      alternatives.forEach(p => {
        const isSelected = String(p.path_id) === clickedPathId;
        const isBestPath = bestPathIds.has(String(p.path_id));
        let rowClass = '';
        if (isSelected) rowClass = 'selected-row';
        if (isBestPath) rowClass += (rowClass ? ' ' : '') + 'best-path-row';
        tableHTML += `<tr data-path-id="${p.path_id}"${rowClass ? ' class="' + rowClass + '"' : ''}>`;
        displayedColumns.forEach(col => {
          const value = p[col] !== undefined ? p[col] : '';
          let displayValue;
          if (typeof value === 'number') {
            if (Number.isInteger(value)) {
              displayValue = String(value);
            } else {
              // Preserve precision for specific columns like fuzz_factor
              if (col === 'fuzz_factor') {
                displayValue = String(value);
              } else {
                displayValue = value.toFixed(2);
              }
            }
          } else {
            displayValue = String(value);
          }
          tableHTML += `<td>${displayValue}</td>`;
        });
        tableHTML += '</tr>';
      });

      tableHTML += '</tbody></table></div>';

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –º–µ–Ω—é: –æ—Ç–∫—Ä—ã—Ç–æ –ª–∏ –∏ –ø–æ–∑–∏—Ü–∏—é –ø—Ä–æ–∫—Ä—É—Ç–∫–∏
      const oldDropdown = document.getElementById('columns-dropdown');
      const wasDropdownOpen = oldDropdown?.style.display === 'block';
      const scrollPos = oldDropdown?.scrollTop || 0;

      // Clear previous highlights before rendering the new table
      document.querySelectorAll('.corresponding-relation-highlight').forEach(e => e.classList.remove('corresponding-relation-highlight'));

      // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
      container.innerHTML = `
        <div id="columns-controls">${controlsHTML}</div>
        <div id="table-container">${tableHTML}</div>
      `;

      // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      if (wasDropdownOpen) {
        const newDropdown = document.getElementById('columns-dropdown');
        if (newDropdown) {
          newDropdown.style.display = 'block';
          newDropdown.scrollTop = scrollPos;
        }
      }

      if (wasDropdownOpen) {
        document.getElementById('columns-dropdown').style.display = 'block';
      }

      // === –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ ===
      const dropdown = document.getElementById('columns-dropdown');
      const toggleBtn = document.getElementById('toggle-columns-btn');

      // Add event listeners for table type buttons
      const tableButtons = container.querySelectorAll('.table-control-btn');
      if (tableButtons.length > 0) {
        tableButtons.forEach(btn => {
          btn.addEventListener('click', function() {
            const tableType = this.getAttribute('data-table-type');
            currentTableType = tableType;

            // Update active button
            container.querySelectorAll('.table-control-btn').forEach(b => {
              b.classList.remove('active');
            });
            this.classList.add('active');

            // Show the appropriate table
            if (tableType === 'relations') {
              showRelationsTable(clickedPathId);
              // Highlight the corresponding relation
              highlightCorrespondingRelation(clickedPathId);
            } else {
              showAlternativePaths(clickedPathId); // Refresh current view
            }
          });
        });
      }

      toggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';

        // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ indeterminate —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–µ–∫–±–æ–∫—Å–æ–≤ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏
        if (dropdown.style.display === 'block') {
          setTimeout(() => {
            setGroupIndeterminateStates(dropdown);
          }, 0);
        }
      });

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ —á–µ–∫–±–æ–∫—Å–æ–≤
      dropdown.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          if (this.classList.contains('column-checkbox')) {
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞
            const col = this.getAttribute('data-column');
            if (this.checked) {
              visibleColumns.add(col);
            } else {
              visibleColumns.delete(col);
            }
          } else if (this.classList.contains('group-checkbox')) {
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥—Ä—É–ø–ø—ã —Å—Ç–æ–ª–±—Ü–æ–≤
            const groupName = this.getAttribute('data-group');
            const groupColumns = Array.from(dropdown.querySelectorAll(`input[data-group="${groupName}"].column-checkbox`));

            if (this.checked) {
              // –í–∫–ª—é—á–∏—Ç—å –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã –≤ –≥—Ä—É–ø–ø–µ
              groupColumns.forEach(checkbox => {
                const col = checkbox.getAttribute('data-column');
                visibleColumns.add(col);
                checkbox.checked = true;
              });
            } else {
              // –í—ã–∫–ª—é—á–∏—Ç—å –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã –≤ –≥—Ä—É–ø–ø–µ
              groupColumns.forEach(checkbox => {
                const col = checkbox.getAttribute('data-column');
                visibleColumns.delete(col);
                checkbox.checked = false;
              });
            }

            // –û–±–Ω–æ–≤–∏—Ç—å indeterminate —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤—Å–µ—Ö –≥—Ä—É–ø–ø
            setGroupIndeterminateStates(dropdown);
          }

          // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∞—Ç—å —Ç–∞–±–ª–∏—Ü—É –æ–¥–∏–Ω —Ä–∞–∑ –ø–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
          showAlternativePaths(clickedPathId);
        });
      });

      const searchInput = document.getElementById('table-search');
      const rows = container.querySelectorAll('#table-wrapper tbody tr');

      searchInput.addEventListener('input', () => {
        const term = searchInput.value.toLowerCase().trim();
        rows.forEach(row => {
          let found = term === '';
          if (!found) {
            const cells = row.querySelectorAll('td');
            for (const cell of cells) {
              if (cell.textContent.toLowerCase().includes(term)) {
                found = true;
                break;
              }
            }
          }
          row.style.display = found ? '' : 'none';
        });
      });

      // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ ‚Äî —Ç–æ–ª—å–∫–æ –ø–æ –≤–∏–¥–∏–º—ã–º —Å—Ç–æ–ª–±—Ü–∞–º
      displayedColumns.forEach((col, idx) => {
        const th = container.querySelector(`#table-wrapper th[data-column="${col}"]`);
        if (th) {
          th.addEventListener('click', () => {
            let newSort;
            if (th.classList.contains('sort-asc')) {
              newSort = 'desc';
            } else if (th.classList.contains('sort-desc')) {
              newSort = null;
            } else {
              newSort = 'asc';
            }

            container.querySelectorAll('#table-wrapper th').forEach(t => {
              t.classList.remove('sort-asc', 'sort-desc');
            });

            if (newSort) {
              th.classList.add(newSort === 'asc' ? 'sort-asc' : 'sort-desc');
            }

            if (newSort) {
              const tbody = th.closest('table').querySelector('tbody');
              const visibleRows = Array.from(tbody.querySelectorAll('tr')).filter(row => row.style.display !== 'none');

              visibleRows.sort((a, b) => {
                const aValue = a.cells[idx]?.textContent.trim() || '';
                const bValue = b.cells[idx]?.textContent.trim() || '';

                let aNum = parseFloat(aValue);
                let bNum = parseFloat(bValue);

                if (!isNaN(aNum) && !isNaN(bNum)) {
                  return newSort === 'asc' ? aNum - bNum : bNum - aNum;
                } else {
                  return newSort === 'asc'
                    ? aValue.localeCompare(bValue)
                    : bValue.localeCompare(aValue);
                }
              });

              visibleRows.forEach(row => tbody.appendChild(row));
            } else {
              const tableWrapper = document.getElementById('table-wrapper');
              const verticalScroll = tableWrapper.scrollTop;
              const horizontalScroll = tableWrapper.scrollLeft;

              const tbody = th.closest('table').querySelector('tbody');
              const allRows = Array.from(tbody.children);
              allRows.sort((a, b) => {
                const aPathId = parseInt(a.getAttribute('data-path-id'));
                const bPathId = parseInt(b.getAttribute('data-path-id'));
                return aPathId - bPathId;
              });

              allRows.forEach(row => tbody.appendChild(row));

              tableWrapper.scrollTop = verticalScroll;
              tableWrapper.scrollLeft = horizontalScroll;
            }
          });
        }
      });

      // –ö–ª–∏–∫ –ø–æ —Å—Ç—Ä–æ–∫–µ —Ç–∞–±–ª–∏—Ü—ã
      container.querySelectorAll('#table-wrapper tbody tr').forEach(row => {
        row.addEventListener('click', () => {
          const pathId = row.getAttribute('data-path-id');
          if (!pathId) return;

          // –°–±—Ä–æ—Å –≤—ã–¥–µ–ª–µ–Ω–∏—è –≤ EXPLAIN –∏ —Ç–∞–±–ª–∏—Ü–µ
          document.querySelectorAll('.path-line.selected').forEach(e => e.classList.remove('selected'));
          document.querySelectorAll('.path-line.child-highlight').forEach(e => e.classList.remove('child-highlight'));
          document.querySelectorAll('.selected-row').forEach(e => e.classList.remove('selected-row'));

          // Clear the corresponding relation highlight
          document.querySelectorAll('.corresponding-relation-highlight').forEach(e => e.classList.remove('corresponding-relation-highlight'));

          // –í—ã–¥–µ–ª–µ–Ω–∏–µ –≤ EXPLAIN
          const explainLine = document.querySelector(`.path-line[data-path-id="${pathId}"]`);
          if (explainLine) explainLine.classList.add('selected');

          // –í—ã–¥–µ–ª–µ–Ω–∏–µ –≤ —Ç–∞–±–ª–∏—Ü–µ
          // Preserve the best-path-row class if this is a best path
          const isBestPath = bestPathIds.has(pathId);
          row.className = 'selected-row' + (isBestPath ? ' best-path-row' : '');

          currentSelectedPathId = pathId;
          highlightPathInTree(pathId);

          if (bestPathIds.has(pathId)) {
            highlightChildNodesInExplain(pathId);
          }

          // Check the current table type and update accordingly
          if (currentTableType === 'relations') {
            // Stay on relations table but update with new clicked path context
            showRelationsTable(pathId);

            // Highlight the corresponding relation in the relations table
            highlightCorrespondingRelation(pathId);
          } else {
            // For alternative paths table, behave as before
            // Also render the selected path with its children in the right panel
            renderSelectedPathWithChildren(pathId);
          }
        });

        row.addEventListener('dblclick', () => {
          const pathId = row.getAttribute('data-path-id');
          if (pathId) {
            const node = cy.getElementById(pathId);
            if (node && node.length > 0) {
              cy.animate({
                center: {
                  eles: node
                },
                zoom: 1.2,
                duration: 500
              });
            } else {
              const path = nodeMap.get(pathId);
              if (path) {
                const idsToTry = [
                  `relation-${path._relKey}`,
                  `level-${path._levelKey}`,
                  `subquery-${path._subKey}`
                ];

                for (const id of idsToTry) {
                  const containerNode = cy.getElementById(id);
                  if (containerNode && containerNode.length > 0) {
                    cy.animate({
                      center: {
                        eles: containerNode
                      },
                      zoom: 1.2,
                      duration: 500
                    });
                    break;
                  }
                }
              }
            }
          }
        });
      });
    }

    function highlightCorrespondingRelation(pathId) {
      // Get the selected path
      const selectedPath = nodeMap.get(pathId);
      if (!selectedPath) return;

      // Find the corresponding relation in the relations table
      const relId = selectedPath.rel_id;
      const subqueryId = selectedPath.subquery_id;
      const level = selectedPath.level;

      // Find the header indices in the relations table
      const headerCells = document.querySelectorAll('#table-container thead th');
      let subqueryIdIndex = -1;
      let levelIndex = -1;
      let relIdIndex = -1;

      for (let i = 0; i < headerCells.length; i++) {
        const headerText = headerCells[i].textContent.trim();
        if (headerText === 'subquery_id') {
          subqueryIdIndex = i;
        } else if (headerText === 'level') {
          levelIndex = i;
        } else if (headerText === 'rel_id') {
          relIdIndex = i;
        }
      }

      // Find the row in the relations table that matches this relation
      const tableRows = document.querySelectorAll('#table-container tbody tr');
      tableRows.forEach(row => {
        // Check if this row corresponds to the selected relation
        const cells = row.querySelectorAll('td');

        // Check if we have the required indices and enough cells in the row
        if (subqueryIdIndex !== -1 && levelIndex !== -1 && relIdIndex !== -1 &&
            cells.length > Math.max(subqueryIdIndex, levelIndex, relIdIndex)) {

          const rowSubqueryId = cells[subqueryIdIndex].textContent.trim();
          const rowLevel = cells[levelIndex].textContent.trim();
          const rowRelId = cells[relIdIndex].textContent.trim();

          if (parseInt(rowSubqueryId) === subqueryId &&
              parseInt(rowLevel) === level &&
              parseInt(rowRelId) === relId) {
            // Highlight this row
            document.querySelectorAll('#table-container tbody tr.corresponding-relation-highlight').forEach(e => e.classList.remove('corresponding-relation-highlight'));
            row.classList.add('corresponding-relation-highlight');
          }
        }
      });
    }

    function showRelationsTable(clickedPathId) {
      const clickedPath = nodeMap.get(clickedPathId);
      if (!clickedPath) return;

      const container = document.getElementById('empty-container');

      // Get the level and subquery_id of the clicked path
      const targetLevel = clickedPath.level;
      const targetSubqueryId = clickedPath.subquery_id;

      // Get only relations from the same level and subquery as the clicked path
      const relations = new Map();
      for (const [pathId, path] of nodeMap.entries()) {
        // Only include paths that are in the same level and subquery as the clicked path
        if (path.level === targetLevel && path.subquery_id === targetSubqueryId) {
          const relKey = path._relKey;
          if (!relations.has(relKey)) {
            // Extract the relation information from the original data
            const relParts = relKey.split('-');
            if (relParts.length >= 3) {
              const subKey = relParts[0];
              const levelStr = relParts[1]; // e.g., "L1"
              const level = levelStr.substring(1); // remove 'L' prefix to get the number
              const relId = relParts[2].substring(1); // remove 'R' prefix to get the number

              // Find the original relation object in the data structure
              let originalRel = null;
              for (const [queryId, query] of Object.entries(globalData.queries)) {
                for (const [subqueryId, subquery] of Object.entries(query.subqueries)) {
                  if (subqueryId === subKey) {
                    for (const [levelCheck, levelObj] of Object.entries(subquery.levels)) {
                      if (levelCheck === level) {
                        for (const [relIdCheck, relObj] of Object.entries(levelObj.relations)) {
                          if (relIdCheck === relId) {
                            originalRel = relObj;
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }

              // Create a relation object with original data
              const relData = {
                subquery_id: path.subquery_id,
                subquery_level: path.subquery_level,
                level: path.level,
                rel_id: path.rel_id,
                rel_name: path.rel_name || null,
                rel_alias: path.rel_alias || null,
                path_count: 0, // Will be counted later
                paths: [] // Will be filled later
              };

              // Add any additional fields from the original relation object
              if (originalRel) {
                for (const [key, value] of Object.entries(originalRel)) {
                  if (!relData.hasOwnProperty(key)) {
                    relData[key] = value;
                  }
                }
              }

              relations.set(relKey, relData);
            }
          }

          // Add path to the relation
          const relData = relations.get(relKey);
          relData.path_count = (relData.path_count || 0) + 1;
          relData.paths = relData.paths || [];
          relData.paths.push(path);
        }
      }

      // Convert map values to array
      const relationsArray = Array.from(relations.values());

      // Define column order for relations table
      const relationColumns = [
        "subquery_id", "subquery_level", "level", "rel_id",
        "rel_name", "rel_alias", "path_count"
      ];

      // Create controls HTML with buttons
      let controlsHTML = `
        <div id="table-controls">
          <button class="table-control-btn ${currentTableType === 'alternative-paths' ? 'active' : ''}" data-table-type="alternative-paths">–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø—É—Ç–∏</button>
          <button class="table-control-btn ${currentTableType === 'relations' ? 'active' : ''}" data-table-type="relations">–û—Ç–Ω–æ—à–µ–Ω–∏—è</button>
        </div>
        <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap; margin-top:10px;">
          <input type="text" id="table-search" placeholder="üîç –ü–æ–∏—Å–∫ –≤ —Ç–∞–±–ª–∏—Ü–µ..."
                style="flex:1; min-width:150px; padding:6px 10px; border:1px solid #ccc; border-radius:3px; font-size:13px;">
          <div style="position:relative; display:inline-block;">
            <button id="toggle-columns-btn" type="button"
                    style="padding:6px 10px; border:1px solid #ccc; background:#fff; border-radius:3px; cursor:pointer; font-size:13px;">
              ‚öôÔ∏è –°—Ç–æ–ª–±—Ü—ã
            </button>
            <div id="columns-dropdown" style="display:none; position:absolute; top:100%; right:0; background:#fff; border:1px solid #ccc; border-radius:3px; z-index:1000; max-height:300px; overflow-y:auto; box-shadow:0 2px 6px rgba(0,0,0,0.2);">
              <!-- Relations columns dropdown -->
            </div>
          </div>
        </div>
      `;

      let tableHTML = `<div id="table-wrapper" style="max-height:100%; overflow:auto;"><table><thead><tr>`;

      // Add headers for relations table
      relationColumns.forEach(col => {
        tableHTML += `<th data-column="${col}">${col}</th>`;
      });
      tableHTML += '</tr></thead><tbody>';

      // Add rows for each relation
      relationsArray.forEach(rel => {
        tableHTML += '<tr>';
        relationColumns.forEach(col => {
          let value = rel[col] !== undefined ? rel[col] : '';
          if (typeof value === 'number') {
            if (Number.isInteger(value)) {
              value = String(value);
            } else {
              value = value.toFixed(2);
            }
          } else {
            value = String(value);
          }
          tableHTML += `<td>${value}</td>`;
        });
        tableHTML += '</tr>';
      });

      tableHTML += '</tbody></table></div>';

      // Clear previous highlights before rendering the new table
      document.querySelectorAll('.corresponding-relation-highlight').forEach(e => e.classList.remove('corresponding-relation-highlight'));

      // Render the relations table
      container.innerHTML = `
        <div id="columns-controls">${controlsHTML}</div>
        <div id="table-container">${tableHTML}</div>
      `;

      // Add event listeners for table type buttons
      const tableButtons = container.querySelectorAll('.table-control-btn');
      if (tableButtons.length > 0) {
        tableButtons.forEach(btn => {
          btn.addEventListener('click', function() {
            const tableType = this.getAttribute('data-table-type');
            currentTableType = tableType;

            // Update active button
            container.querySelectorAll('.table-control-btn').forEach(b => {
              b.classList.remove('active');
            });
            this.classList.add('active');

            // Show the appropriate table
            if (tableType === 'alternative-paths') {
              showAlternativePaths(clickedPathId);
            } else {
              showRelationsTable(clickedPathId); // Refresh current view
              // Highlight the corresponding relation
              highlightCorrespondingRelation(clickedPathId);
            }
          });
        });
      }

      // Add search functionality
      const searchInput = document.getElementById('table-search');
      const rows = container.querySelectorAll('#table-wrapper tbody tr');

      searchInput.addEventListener('input', () => {
        const term = searchInput.value.toLowerCase().trim();
        rows.forEach(row => {
          let found = term === '';
          if (!found) {
            const cells = row.querySelectorAll('td');
            for (const cell of cells) {
              if (cell.textContent.toLowerCase().includes(term)) {
                found = true;
                break;
              }
            }
          }
          row.style.display = found ? '' : 'none';
        });
      });

      // Add sorting functionality
      relationColumns.forEach((col, idx) => {
        const th = container.querySelector(`#table-wrapper th[data-column="${col}"]`);
        if (th) {
          th.addEventListener('click', () => {
            let newSort;
            if (th.classList.contains('sort-asc')) {
              newSort = 'desc';
            } else if (th.classList.contains('sort-desc')) {
              newSort = null;
            } else {
              newSort = 'asc';
            }

            container.querySelectorAll('#table-wrapper th').forEach(t => {
              t.classList.remove('sort-asc', 'sort-desc');
            });

            if (newSort) {
              th.classList.add(newSort === 'asc' ? 'sort-asc' : 'sort-desc');
            }

            if (newSort) {
              const tbody = th.closest('table').querySelector('tbody');
              const visibleRows = Array.from(tbody.querySelectorAll('tr')).filter(row => row.style.display !== 'none');

              visibleRows.sort((a, b) => {
                const aValue = a.cells[idx]?.textContent.trim() || '';
                const bValue = b.cells[idx]?.textContent.trim() || '';

                let aNum = parseFloat(aValue);
                let bNum = parseFloat(bValue);

                if (!isNaN(aNum) && !isNaN(bNum)) {
                  return newSort === 'asc' ? aNum - bNum : bNum - aNum;
                } else {
                  return newSort === 'asc'
                    ? aValue.localeCompare(bValue)
                    : bValue.localeCompare(aValue);
                }
              });

              visibleRows.forEach(row => tbody.appendChild(row));
            } else {
              const tableWrapper = document.getElementById('table-wrapper');
              const verticalScroll = tableWrapper.scrollTop;
              const horizontalScroll = tableWrapper.scrollLeft;

              const tbody = th.closest('table').querySelector('tbody');
              const allRows = Array.from(tbody.children);
              allRows.sort((a, b) => {
                const aValue = a.cells[0]?.textContent.trim() || '';
                const bValue = b.cells[0]?.textContent.trim() || '';
                return aValue.localeCompare(bValue);
              });

              allRows.forEach(row => tbody.appendChild(row));

              tableWrapper.scrollTop = verticalScroll;
              tableWrapper.scrollLeft = horizontalScroll;
            }
          });
        }
      });

      // Add click functionality to rows
      container.querySelectorAll('#table-wrapper tbody tr').forEach(row => {
        row.addEventListener('click', () => {
          // Clear all selections and highlights
          document.querySelectorAll('.path-line.selected').forEach(e => e.classList.remove('selected'));
          document.querySelectorAll('.path-line.child-highlight').forEach(e => e.classList.remove('child-highlight'));
          document.querySelectorAll('.selected-row').forEach(e => e.classList.remove('selected-row'));
          cy.elements('.selected-in-tree').removeClass('selected-in-tree');

          // Clear the current selected path
          currentSelectedPathId = null;

          // Highlight the clicked relation row
          row.classList.add('selected-row');

          // Remove the corresponding relation highlight when clicking on a relation row
          document.querySelectorAll('.corresponding-relation-highlight').forEach(e => e.classList.remove('corresponding-relation-highlight'));

          // Get the relation data from the clicked row
          const cells = row.querySelectorAll('td');
          const subqueryIdCell = cells[0]; // subquery_id is the first column
          const levelCell = cells[2];     // level is the third column
          const relIdCell = cells[3];     // rel_id is the fourth column

          if (subqueryIdCell && levelCell && relIdCell) {
            const subqueryId = parseInt(subqueryIdCell.textContent.trim());
            const level = parseInt(levelCell.textContent.trim());
            const relId = parseInt(relIdCell.textContent.trim());

            // Find a path that belongs to this relation to use as reference
            let referencePath = null;
            for (const [pathId, path] of nodeMap.entries()) {
              if (path.subquery_id === subqueryId && path.level === level && path.rel_id === relId) {
                referencePath = path;
                break;
              }
            }

            if (referencePath) {
              // Switch to alternative paths table showing paths for this relation
              currentTableType = 'alternative-paths';

              // Update button states
              container.querySelectorAll('.table-control-btn').forEach(b => {
                b.classList.remove('active');
              });
              const altPathsBtn = container.querySelector('.table-control-btn[data-table-type="alternative-paths"]');
              if (altPathsBtn) {
                altPathsBtn.classList.add('active');
              }

              // Show alternative paths for this relation
              showAlternativePathsForRelation(subqueryId, level, relId, referencePath._relKey);

              // Find and select the first alternative path
              const alternatives = Array.from(nodeMap.values()).filter(p =>
                p.subquery_id === subqueryId && p.level === level && p.rel_id === relId
              );

              if (alternatives.length > 0) {
                // Select the first path in the alternatives
                const firstPath = alternatives[0];
                const firstPathId = String(firstPath.path_id);

                // Update the current selected path
                currentSelectedPathId = firstPathId;

                // Highlight the first path in the table after it's rendered
                setTimeout(() => {
                  const firstRow = document.querySelector(`#table-wrapper tbody tr[data-path-id="${firstPathId}"]`);
                  if (firstRow) {
                    // Remove any existing selections in the table
                    document.querySelectorAll('#table-wrapper tbody tr.selected-row').forEach(row => {
                      row.classList.remove('selected-row');
                    });
                    // Add selection to the current row
                    firstRow.classList.add('selected-row');

                    // Highlight the corresponding line in the EXPLAIN panel
                    const explainLine = document.querySelector(`.path-line[data-path-id="${firstPathId}"]`);
                    if (explainLine) {
                      explainLine.classList.add('selected');
                    }
                  }
                }, 10); // Small delay to ensure the table is rendered

                // Highlight the path in the tree
                highlightPathInTree(firstPathId);

                // Render the selected path with its children in the right panel
                renderSelectedPathWithChildren(firstPathId);

                // Highlight the relation node in the graph
                const relationNodeId = `relation-${referencePath._relKey}`;
                const relationNode = cy.getElementById(relationNodeId);
                if (relationNode && relationNode.length > 0) {
                  relationNode.addClass('selected-in-tree');
                  cy.animate({
                    center: {
                      eles: relationNode
                    },
                    zoom: 1.2,
                    duration: 500
                  });
                } else {
                  // If the relation node doesn't exist, try to find the parent containers
                  const levelNodeId = `level-${referencePath._levelKey}`;
                  const levelNode = cy.getElementById(levelNodeId);
                  if (levelNode && levelNode.length > 0) {
                    levelNode.addClass('selected-in-tree');
                    cy.animate({
                      center: {
                        eles: levelNode
                      },
                      zoom: 1.2,
                      duration: 500
                    });
                  }
                }
              } else {
                // If no alternatives found, just highlight the relation in the graph
                const relationNodeId = `relation-${referencePath._relKey}`;
                const relationNode = cy.getElementById(relationNodeId);
                if (relationNode && relationNode.length > 0) {
                  relationNode.addClass('selected-in-tree');
                  cy.animate({
                    center: {
                      eles: relationNode
                    },
                    zoom: 1.2,
                    duration: 500
                  });
                } else {
                  // If the relation node doesn't exist, try to find the parent containers
                  const levelNodeId = `level-${referencePath._levelKey}`;
                  const levelNode = cy.getElementById(levelNodeId);
                  if (levelNode && levelNode.length > 0) {
                    levelNode.addClass('selected-in-tree');
                    cy.animate({
                      center: {
                        eles: levelNode
                      },
                      zoom: 1.2,
                      duration: 500
                    });
                  }
                }
              }
            }
          }
        });
      });

      // If there's a currently selected path, highlight its corresponding relation
      if (currentSelectedPathId) {
        highlightCorrespondingRelation(currentSelectedPathId);
      }
    }

    function highlightPathInTree(pathId) {
      // –°–±—Ä–æ—Å —Å—Ç–∞—Ä–æ–π –ø–æ–¥ÔøΩÔøΩÔøΩÔøΩ–≤–µ—Ç–∫–∏
      cy.elements('.selected-in-tree').removeClass('selected-in-tree');

      const path = nodeMap.get(pathId);
      if (!path) return;

      const subqueryId = `subquery-${path._subKey}`;
      const levelId = `level-${path._levelKey}`;
      const relationId = `relation-${path._relKey}`;

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤ –ø–æ—Ä—è–¥–∫–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞: –ø—É—Ç—å -> –æ—Ç–Ω–æ—à–µ–Ω–∏–µ -> —É—Ä–æ–≤–µ–Ω—å -> –ø–æ–¥–∑–∞–ø—Ä–æ—Å
      let targetId = null;

      if (cy.getElementById(pathId).length > 0) {
        targetId = pathId;
      } else if (cy.getElementById(relationId).length > 0) {
        targetId = relationId;
      } else if (cy.getElementById(levelId).length > 0) {
        targetId = levelId;
      } else if (cy.getElementById(subqueryId).length > 0) {
        targetId = subqueryId;
      }

      if (targetId) {
        cy.getElementById(targetId).addClass('selected-in-tree');
      }
    }

    function highlightChildNodesInExplain(parentPathId) {
      document.querySelectorAll('.path-line.child-highlight').forEach(el => {
        el.classList.remove('child-highlight');
      });

      const parentPath = nodeMap.get(parentPathId);
      if (!parentPath || !Array.isArray(parentPath.child_paths) || parentPath.child_paths.length === 0) {
        return;
      }

      parentPath.child_paths.forEach(childId => {
        const childElement = document.querySelector(`.path-line[data-path-id="${childId}"]`);
        if (childElement) {
          childElement.classList.add('child-highlight');
        }
      });
    }

    function showAlternativePathsForRelation(subqueryId, level, relId, relKey) {
      // Get all paths that belong to this relation
      const alternatives = Array.from(nodeMap.values()).filter(p =>
        p.subquery_id === subqueryId && p.level === level && p.rel_id === relId
      );

      const container = document.getElementById('empty-container');
      if (alternatives.length === 0) {
        container.innerHTML = '–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø—É—Ç–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –æ—Ç–Ω–æ—à–µ–Ω–∏—è.';
        return;
      }

      const COLUMN_ORDER = [
        "query_id", "subquery_id", "subquery_level", "rel_id", "path_id",
        "path_type", "rel_name", "rel_alias", "indexoid", "level",
        "child_paths", "startup_cost", "total_cost", "rows", "width",
        "add_path_result", "displaced_by", "cost_cmp", "fuzz_factor",
        "pathkeys_cmp", "bms_cmp", "rows_cmp", "parallel_safe_cmp"
      ];

      const allKeys = new Set();
      for (const p of alternatives) {
        for (const key in p) {
          if (!key.startsWith('_')) {
            allKeys.add(key);
          }
        }
      }

      const orderedColumns = COLUMN_ORDER.filter(col => allKeys.has(col));
      const extraKeys = Array.from(allKeys).filter(k => !COLUMN_ORDER.includes(k));
      const allColumns = [...orderedColumns, ...extraKeys];

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–¥–∏–Ω —Ä–∞–∑
      if (globalVisibleColumns === null) {
        globalVisibleColumns = new Set(allColumns);
      } else {
        // –£–¥–∞–ª—è–µ–º —Å—Ç–æ–ª–±—Ü—ã, –∫–æ—Ç–æ—Ä—ã—Ö –±–æ–ª—å—à–µ –Ω–µ—Ç –≤ —Ç–µ–∫—É—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        for (const col of Array.from(globalVisibleColumns)) {
          if (!allColumns.includes(col)) {
            globalVisibleColumns.delete(col);
          }
        }
      }
      const visibleColumns = globalVisibleColumns;

      // –£–¥–∞–ª—è–µ–º —Å—Ç–æ–ª–±—Ü—ã, –∫–æ—Ç–æ—Ä—ã—Ö –±–æ–ª—å—à–µ –Ω–µ—Ç –≤ –¥–∞–Ω–Ω—ã—Ö
      for (const col of Array.from(visibleColumns)) { // ‚Üê –≤–∞–∂–Ω–æ: Array.from, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–∫–∏ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏
        if (!allColumns.includes(col)) {
          visibleColumns.delete(col);
        }
      }

      // –§–æ—Ä–º–∏—Ä—É–µ–º HTML
      let controlsHTML = `
        <div id="table-controls">
          <button class="table-control-btn ${currentTableType === 'alternative-paths' ? 'active' : ''}" data-table-type="alternative-paths">–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø—É—Ç–∏</button>
          <button class="table-control-btn ${currentTableType === 'relations' ? 'active' : ''}" data-table-type="relations">–û—Ç–Ω–æ—à–µ–Ω–∏—è</button>
        </div>
        <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap; margin-top:10px;">
          <input type="text" id="table-search" placeholder="üîç –ü–æ–∏—Å–∫ –≤ —Ç–∞–±–ª–∏—Ü–µ..."
                style="flex:1; min-width:150px; padding:6px 10px; border:1px solid #ccc; border-radius:3px; font-size:13px;">
          <div style="position:relative; display:inline-block;">
            <button id="toggle-columns-btn" type="button"
                    style="padding:6px 10px; border:1px solid #ccc; background:#fff; border-radius:3px; cursor:pointer; font-size:13px;">
              ‚öôÔ∏è –°—Ç–æ–ª–±—Ü—ã
            </button>
            <div id="columns-dropdown" style="display:none; position:absolute; top:100%; right:0; background:#fff; border:1px solid #ccc; border-radius:3px; z-index:1000; max-height:300px; overflow-y:auto; box-shadow:0 2px 6px rgba(0,0,0,0.2);">
              ${renderGroupedColumns(allColumns, visibleColumns)}
            </div>
          </div>
        </div>
      `;

      let tableHTML = `<div id="table-wrapper" style="max-height:100%; overflow:auto;"><table><thead><tr>`;

      // –¢–æ–ª—å–∫–æ –≤–∏–¥–∏–º—ã–µ —Å—Ç–æ–ª–±—Ü—ã
      const displayedColumns = allColumns.filter(col => visibleColumns.has(col));
      displayedColumns.forEach(col => {
        tableHTML += `<th data-column="${col}">${col}</th>`;
      });
      tableHTML += '</tr></thead><tbody>';

      alternatives.forEach(p => {
        const isBestPath = bestPathIds.has(String(p.path_id));
        const rowClass = isBestPath ? 'best-path-row' : '';
        tableHTML += `<tr data-path-id="${p.path_id}"${rowClass ? ' class="' + rowClass + '"' : ''}>`;
        displayedColumns.forEach(col => {
          const value = p[col] !== undefined ? p[col] : '';
          let displayValue;
          if (typeof value === 'number') {
            if (Number.isInteger(value)) {
              displayValue = String(value);
            } else {
              // Preserve precision for specific columns like fuzz_factor
              if (col === 'fuzz_factor') {
                displayValue = String(value);
              } else {
                displayValue = value.toFixed(2);
              }
            }
          } else {
            displayValue = String(value);
          }
          tableHTML += `<td>${displayValue}</td>`;
        });
        tableHTML += '</tr>';
      });

      tableHTML += '</tbody></table></div>';

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –º–µ–Ω—é: –æ—Ç–∫—Ä—ã—Ç–æ –ª–∏ –∏ –ø–æ–∑–∏—Ü–∏—é –ø—Ä–æ–∫—Ä—É—Ç–∫–∏
      const oldDropdown = document.getElementById('columns-dropdown');
      const wasDropdownOpen = oldDropdown?.style.display === 'block';
      const scrollPos = oldDropdown?.scrollTop || 0;

      // Clear previous highlights before rendering the new table
      document.querySelectorAll('.corresponding-relation-highlight').forEach(e => e.classList.remove('corresponding-relation-highlight'));

      // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
      container.innerHTML = `
        <div id="columns-controls">${controlsHTML}</div>
        <div id="table-container">${tableHTML}</div>
      `;

      // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      if (wasDropdownOpen) {
        const newDropdown = document.getElementById('columns-dropdown');
        if (newDropdown) {
          newDropdown.style.display = 'block';
          newDropdown.scrollTop = scrollPos;
        }
      }

      if (wasDropdownOpen) {
        document.getElementById('columns-dropdown').style.display = 'block';
      }

      // === –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ ===
      const dropdown = document.getElementById('columns-dropdown');
      const toggleBtn = document.getElementById('toggle-columns-btn');

      // Add event listeners for table type buttons
      const tableButtons = container.querySelectorAll('.table-control-btn');
      if (tableButtons.length > 0) {
        tableButtons.forEach(btn => {
          btn.addEventListener('click', function() {
            const tableType = this.getAttribute('data-table-type');
            currentTableType = tableType;

            // Update active button
            container.querySelectorAll('.table-control-btn').forEach(b => {
              b.classList.remove('active');
            });
            this.classList.add('active');

            // Show the appropriate table
            if (tableType === 'relations') {
              // Find a path that belongs to this relation to use as reference for relations table
              let referencePath = null;
              for (const [pathId, path] of nodeMap.entries()) {
                if (path.subquery_id === subqueryId && path.level === level && path.rel_id === relId) {
                  referencePath = path;
                  break;
                }
              }
              if (referencePath) {
                showRelationsTable(String(referencePath.path_id));
              }
            } else {
              // For alternative paths table, show paths for this relation
              showAlternativePathsForRelation(subqueryId, level, relId, relKey);
            }
          });
        });
      }

      toggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';

        // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ indeterminate —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–µ–∫–±–æ–∫—Å–æ–≤ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏
        if (dropdown.style.display === 'block') {
          setTimeout(() => {
            setGroupIndeterminateStates(dropdown);
          }, 0);
        }
      });

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ —á–µ–∫–±–æ–∫—Å–æ–≤
      dropdown.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          if (this.classList.contains('column-checkbox')) {
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞
            const col = this.getAttribute('data-column');
            if (this.checked) {
              visibleColumns.add(col);
            } else {
              visibleColumns.delete(col);
            }
          } else if (this.classList.contains('group-checkbox')) {
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥—Ä—É–ø–ø—ã —Å—Ç–æ–ª–±—Ü–æ–≤
            const groupName = this.getAttribute('data-group');
            const groupColumns = Array.from(dropdown.querySelectorAll(`input[data-group="${groupName}"].column-checkbox`));

            if (this.checked) {
              // –í–∫–ª—é—á–∏—Ç—å –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã –≤ –≥—Ä—É–ø–ø–µ
              groupColumns.forEach(checkbox => {
                const col = checkbox.getAttribute('data-column');
                visibleColumns.add(col);
                checkbox.checked = true;
              });
            } else {
              // –í—ã–∫–ª—é—á–∏—Ç—å –≤—Å–µ —Å—Ç–æ–ª–±—Ü—ã –≤ –≥—Ä—É–ø–ø–µ
              groupColumns.forEach(checkbox => {
                const col = checkbox.getAttribute('data-column');
                visibleColumns.delete(col);
                checkbox.checked = false;
              });
            }

            // –û–±–Ω–æ–≤–∏—Ç—å indeterminate —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤—Å–µ—Ö –≥—Ä—É–ø–ø
            setGroupIndeterminateStates(dropdown);
          }

          // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∞—Ç—å —Ç–∞–±–ª–∏—Ü—É –æ–¥–∏–Ω —Ä–∞–∑ –ø–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
          showAlternativePathsForRelation(subqueryId, level, relId, relKey);
        });
      });

      const searchInput = document.getElementById('table-search');
      const rows = container.querySelectorAll('#table-wrapper tbody tr');

      searchInput.addEventListener('input', () => {
        const term = searchInput.value.toLowerCase().trim();
        rows.forEach(row => {
          let found = term === '';
          if (!found) {
            const cells = row.querySelectorAll('td');
            for (const cell of cells) {
              if (cell.textContent.toLowerCase().includes(term)) {
                found = true;
                break;
              }
            }
          }
          row.style.display = found ? '' : 'none';
        });
      });

      // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ ‚Äî —Ç–æ–ª—å–∫–æ –ø–æ –≤–∏–¥–∏–º—ã–º —Å—Ç–æ–ª–±—Ü–∞–º
      displayedColumns.forEach((col, idx) => {
        const th = container.querySelector(`#table-wrapper th[data-column="${col}"]`);
        if (th) {
          th.addEventListener('click', () => {
            let newSort;
            if (th.classList.contains('sort-asc')) {
              newSort = 'desc';
            } else if (th.classList.contains('sort-desc')) {
              newSort = null;
            } else {
              newSort = 'asc';
            }

            container.querySelectorAll('#table-wrapper th').forEach(t => {
              t.classList.remove('sort-asc', 'sort-desc');
            });

            if (newSort) {
              th.classList.add(newSort === 'asc' ? 'sort-asc' : 'sort-desc');
            }

            if (newSort) {
              const tbody = th.closest('table').querySelector('tbody');
              const visibleRows = Array.from(tbody.querySelectorAll('tr')).filter(row => row.style.display !== 'none');

              visibleRows.sort((a, b) => {
                const aValue = a.cells[idx]?.textContent.trim() || '';
                const bValue = b.cells[idx]?.textContent.trim() || '';

                let aNum = parseFloat(aValue);
                let bNum = parseFloat(bValue);

                if (!isNaN(aNum) && !isNaN(bNum)) {
                  return newSort === 'asc' ? aNum - bNum : bNum - aNum;
                } else {
                  return newSort === 'asc'
                    ? aValue.localeCompare(bValue)
                    : bValue.localeCompare(aValue);
                }
              });

              visibleRows.forEach(row => tbody.appendChild(row));
            } else {
              const tableWrapper = document.getElementById('table-wrapper');
              const verticalScroll = tableWrapper.scrollTop;
              const horizontalScroll = tableWrapper.scrollLeft;

              const tbody = th.closest('table').querySelector('tbody');
              const allRows = Array.from(tbody.children);
              allRows.sort((a, b) => {
                const aPathId = parseInt(a.getAttribute('data-path-id'));
                const bPathId = parseInt(b.getAttribute('data-path-id'));
                return aPathId - bPathId;
              });

              allRows.forEach(row => tbody.appendChild(row));

              tableWrapper.scrollTop = verticalScroll;
              tableWrapper.scrollLeft = horizontalScroll;
            }
          });
        }
      });

      // –ö–ª–∏–∫ –ø–æ —Å—Ç—Ä–æ–∫–µ —Ç–∞–±–ª–∏—Ü—ã
      container.querySelectorAll('#table-wrapper tbody tr').forEach(row => {
        row.addEventListener('click', () => {
          const pathId = row.getAttribute('data-path-id');
          if (!pathId) return;

          // –°–±—Ä–æ—Å –≤—ã–¥–µ–ª–µ–Ω–∏—è –≤ EXPLAIN –∏ —Ç–∞–±–ª–∏—Ü–µ
          document.querySelectorAll('.path-line.selected').forEach(e => e.classList.remove('selected'));
          document.querySelectorAll('.path-line.child-highlight').forEach(e => e.classList.remove('child-highlight'));
          document.querySelectorAll('.selected-row').forEach(e => e.classList.remove('selected-row'));

          // Clear the corresponding relation highlight
          document.querySelectorAll('.corresponding-relation-highlight').forEach(e => e.classList.remove('corresponding-relation-highlight'));

          // –í—ã–¥–µ–ª–µ–Ω–∏–µ –≤ EXPLAIN
          const explainLine = document.querySelector(`.path-line[data-path-id="${pathId}"]`);
          if (explainLine) explainLine.classList.add('selected');

          // –í—ã–¥–µ–ª–µ–Ω–∏–µ –≤ —Ç–∞–±–ª–∏—Ü–µ
          // Preserve the best-path-row class if this is a best path
          const isBestPath = bestPathIds.has(pathId);
          row.className = 'selected-row' + (isBestPath ? ' best-path-row' : '');

          currentSelectedPathId = pathId;
          highlightPathInTree(pathId);

          if (bestPathIds.has(pathId)) {
            highlightChildNodesInExplain(pathId);
          }

          // Check the current table type and update accordingly
          if (currentTableType === 'relations') {
            // Stay on relations table but update with new clicked path context
            showRelationsTable(pathId);

            // Highlight the corresponding relation in the relations table
            highlightCorrespondingRelation(pathId);
          } else {
            // For alternative paths table, behave as before
            // Also render the selected path with its children in the right panel
            renderSelectedPathWithChildren(pathId);
          }
        });

        row.addEventListener('dblclick', () => {
          const pathId = row.getAttribute('data-path-id');
          if (pathId) {
            const node = cy.getElementById(pathId);
            if (node && node.length > 0) {
              cy.animate({
                center: {
                  eles: node
                },
                zoom: 1.2,
                duration: 500
              });
            } else {
              const path = nodeMap.get(pathId);
              if (path) {
                const idsToTry = [
                  `relation-${path._relKey}`,
                  `level-${path._levelKey}`,
                  `subquery-${path._subKey}`
                ];

                for (const id of idsToTry) {
                  const containerNode = cy.getElementById(id);
                  if (containerNode && containerNode.length > 0) {
                    cy.animate({
                      center: {
                        eles: containerNode
                      },
                      zoom: 1.2,
                      duration: 500
                    });
                    break;
                  }
                }
              }
            }
          }
        });
      });
    }

    function renderSelectedPathWithChildren(selectedPathId) {
      const selectedPath = nodeMap.get(selectedPathId);
      if (!selectedPath) {
        document.getElementById('explain-selected-container').textContent = "–í—ã–±—Ä–∞–Ω–Ω—ã–π –ø—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω.";
        return;
      }

      const lines = [];

      // Add header for the selected path
      lines.push({ text: "–í—ã–±—Ä–∞–Ω–Ω—ã–π –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å", pathId: null });

      // Recursive function to collect all children of the selected path
      const collectLines = (path, depth) => {
        const idStr = String(path.path_id);
        const indent = "  ".repeat(depth);

        let line = `${indent}-> ${path.path_type}`;
        if (path.rel_name) {
          if (path.rel_alias && path.rel_alias !== path.rel_name) {
            line += ` on ${path.rel_name} ${path.rel_alias}`;
          } else {
            line += ` on ${path.rel_name}`;
          }
        }
        if (path.total_cost !== undefined) {
          line += `  (cost=${path.startup_cost.toFixed(2)}..${path.total_cost.toFixed(2)} rows=${Math.round(path.rows)} width=${path.width})`;
        }
        lines.push({ text: line, pathId: idStr });

        if (Array.isArray(path.child_paths)) {
          for (const childId of path.child_paths) {
            const child = nodeMap.get(String(childId));
            if (child) {
              collectLines(child, depth + 1);
            }
          }
        }
      };

      // Start collecting from the selected path
      collectLines(selectedPath, 0);

      const selectedContainer = document.getElementById('explain-selected-container');
      selectedContainer.innerHTML = lines.map(({ text, pathId }) => {
        if (pathId) {
          return `<div class="path-line" data-path-id="${pathId}">${text}</div>`;
        }
        return `<div class="section-header">${text}</div>`;
      }).join('');

      // Add event listeners to the new path lines
      selectedContainer.querySelectorAll('.path-line').forEach(el => {
        el.addEventListener('click', () => {
          document.querySelectorAll('.path-line.selected').forEach(e => e.classList.remove('selected'));
          document.querySelectorAll('.path-line.child-highlight').forEach(e => e.classList.remove('child-highlight'));
          document.querySelectorAll('.selected-row').forEach(e => e.classList.remove('selected-row'));
          cy.elements('.selected-in-tree').removeClass('selected-in-tree');

          el.classList.add('selected');
          const pathId = el.getAttribute('data-path-id');
          currentSelectedPathId = pathId;

          highlightChildNodesInExplain(pathId);

          // Check the current table type and update accordingly
          if (currentTableType === 'relations') {
            // Stay on relations table but update with new clicked path context
            showRelationsTable(pathId);
            // Highlight the corresponding relation
            highlightCorrespondingRelation(pathId);
          } else {
            // For alternative paths table, behave as before
            showAlternativePaths(pathId);
          }

          highlightPathInTree(pathId);

          // Also render the selected path with its children in the right panel
          renderSelectedPathWithChildren(pathId);
        });

        el.addEventListener('dblclick', () => {
          const pathId = el.getAttribute('data-path-id');
          if (pathId) {
            const node = cy.getElementById(pathId);
            if (node && node.length > 0) {
              cy.animate({
                center: {
                  eles: node
                },
                zoom: 1.2,
                duration: 500
              });
            } else {
              const path = nodeMap.get(pathId);
              if (path) {
                const idsToTry = [
                  `relation-${path._relKey}`,
                  `level-${path._levelKey}`,
                  `subquery-${path._subKey}`
                ];

                for (const id of idsToTry) {
                  const containerNode = cy.getElementById(id);
                  if (containerNode && containerNode.length > 0) {
                    cy.animate({
                      center: {
                        eles: containerNode
                      },
                      zoom: 1.2,
                      duration: 500
                    });
                    break;
                  }
                }
              }
            }
          }
        });
      });
    }

    function makeResizable() {
      const vResizer = document.getElementById('vertical-resizer');
      const hResizer = document.getElementById('horizontal-resizer');
      const explainVResizer = document.getElementById('explain-vertical-resizer');
      let resizing = null;

      // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Ä–µ—Å–∞–π–∑–µ—Ä (–º–µ–∂–¥—É –¥–µ—Ä–µ–≤–æ–º –∏ –ø—Ä–∞–≤–æ–π –ø–∞–Ω–µ–ª—å—é)
      vResizer.addEventListener('mousedown', e => {
        resizing = 'v';
        e.preventDefault();
      });

      // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π —Ä–µ—Å–∞–π–∑–µ—Ä (–º–µ–∂–¥—É EXPLAIN –∏ —Ç–∞–±–ª–∏—Ü–µ–π)
      hResizer.addEventListener('mousedown', e => {
        resizing = 'h';
        e.preventDefault();
      });

      // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Ä–µ—Å–∞–π–∑–µ—Ä –º–µ–∂–¥—É –¥–≤—É–º—è –ø–∞–Ω–µ–ª—è–º–∏ EXPLAIN
      explainVResizer.addEventListener('mousedown', e => {
        resizing = 'ev'; // explain vertical
        e.preventDefault();
      });

      document.addEventListener('mousemove', e => {
        if (!resizing) return;

        if (resizing === 'v') {
          // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –¥–µ–ª–µ–Ω–∏–µ: –¥–µ—Ä–µ–≤–æ | [EXPLAIN + —Ç–∞–±–ª–∏—Ü–∞]
          const main = document.getElementById('main-container');
          const tree = document.getElementById('tree-container');
          const right = document.getElementById('right-container');
          const pct = (e.clientX / main.offsetWidth) * 100;
          tree.style.width = pct + '%';
          right.style.width = (100 - pct) + '%';
        } else if (resizing === 'h') {
          // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –¥–µ–ª–µ–Ω–∏–µ: EXPLAIN | —Ç–∞–±–ª–∏—Ü–∞
          const right = document.getElementById('right-container');
          const explainSplitContainer = document.getElementById('explain-split-container');
          const empty = document.getElementById('empty-container');

          // –ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫—É—Ä—Å–æ—Ä–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–∞–≤–æ–π –ø–∞–Ω–µ–ª–∏
          const rect = right.getBoundingClientRect();
          const offsetY = e.clientY - rect.top;

          const newHeight = Math.max(100, Math.min(offsetY, rect.height - 100));

          explainSplitContainer.style.height = newHeight + 'px';
        } else if (resizing === 'ev') {
          // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –¥–µ–ª–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏ –ø–∞–Ω–µ–ª–∏ EXPLAIN: –õ—É—á—à–∏–π –ø–ª–∞–Ω | –í—ã–±—Ä–∞–Ω–Ω—ã–π –ø—É—Ç—å
          const splitContainer = document.getElementById('explain-split-container');
          const bestPanel = document.getElementById('explain-best-container');
          const selectedPanel = document.getElementById('explain-selected-container');

          // –ü–æ–ª—É—á–∞–µ–º —à–∏—Ä–∏–Ω—É –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
          const containerRect = splitContainer.getBoundingClientRect();
          const relativeX = e.clientX - containerRect.left;

          // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç—ã
          const pct = Math.max(10, Math.min(90, (relativeX / containerRect.width) * 100)); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω –æ—Ç 10% –¥–æ 90%
          const selectedPct = 100 - pct;

          // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º flex-basis –¥–ª—è –∫–∞–∂–¥–æ–π –ø–∞–Ω–µ–ª–∏
          bestPanel.style.flex = `0 0 ${pct}%`;
          selectedPanel.style.flex = `0 0 ${selectedPct}%`;
        }
      });

      document.addEventListener('mouseup', () => {
        if (resizing === 'ev') {
          // Reset flex properties to allow for future resizing
          const bestPanel = document.getElementById('explain-best-container');
          const selectedPanel = document.getElementById('explain-selected-container');
          // Keep the flex basis but allow growing/shrinking
          const bestBasis = bestPanel.style.flexBasis;
          const selectedBasis = selectedPanel.style.flexBasis;
          if (bestBasis && selectedBasis) {
            bestPanel.style.flex = `1 1 ${bestBasis}`;
            selectedPanel.style.flex = `1 1 ${selectedBasis}`;
          }
        }
        resizing = null;
      });
    }

    let globalData = null;

    fetch('data.json?' + Date.now())
      .then(res => res.json())
      .then(data => {
        globalData = data; // Store the data globally so it can be accessed by other functions

        cytoscape.use(cytoscapeDagre);

        nodeMap = new Map();
        subqueryNodes = [];
        levelNodes = new Map();
        relationNodes = new Map();
        levelOrder = new Map();
        expanded = new Map();
        relationFilters = new Map();

        const queries = Object.values(data.queries);
        if (queries.length === 0) throw new Error('–ù–µ—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ data.json');
        const query = queries[0];

        for (const [subqueryId, subquery] of Object.entries(query.subqueries)) {
          const subKey = subqueryId;
          subqueryNodes.push({ id: `subquery-${subKey}`, label: `SubQ ${subqueryId}` });

          if (!levelOrder.has(subKey)) {
            levelOrder.set(subKey, new Set());
          }

          for (const [levelStr, levelObj] of Object.entries(subquery.levels)) {
            const level = parseInt(levelStr, 10);
            levelOrder.get(subKey).add(level);
            const levelKey = `${subKey}-L${level}`;
            levelNodes.set(levelKey, { id: `level-${levelKey}`, label: `level=${level}` });

            for (const [relId, relObj] of Object.entries(levelObj.relations)) {
              const relKey = `${levelKey}-R${relId}`;
              const relLabel = relObj.name ? `rel=${relObj.name}` : `rel_id=${relId}`;
              relationNodes.set(relKey, { id: `relation-${relKey}`, label: relLabel });

            for (const path of relObj.paths) {
              const id = String(path.path_id);
              nodeMap.set(id, {
                ...path,
                _relKey: relKey,
                _levelKey: levelKey,
                _subKey: subKey,
                rel_name: relObj.name
              });
            }
            }
          }
        }

        findAllBestPlans();
        renderAllBestPlans();

        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞—Å–∫—Ä—ã—Ç—å –ª—É—á—à–∏–π –ø—É—Ç—å
        function expandBestPath() {
          function expandNode(path) {
            if (!path) return;

            // –†–∞—Å–∫—Ä—ã–≤–∞–µ–º –∏–µ—Ä–∞—Ä—Ö–∏—é –¥–ª—è —ç—Ç–æ–≥–æ —É–∑–ª–∞
            const subId = `subquery-${path._subKey}`;
            const levelId = `level-${path._levelKey}`;
            const bestGroup = `best-rels-${levelId}`;
            const relId = `relation-${path._relKey}`;
            const bestPathsGroup = `best-paths-${relId}`;

            expanded.set(subId, true);
            expanded.set(levelId, true);
            expanded.set(bestGroup, true);
            expanded.set(relId, true);
            expanded.set(bestPathsGroup, true);

            // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Ä–∞—Å–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ—Ö –ø–æ—Ç–æ–º–∫–æ–≤
            if (Array.isArray(path.child_paths)) {
              for (const childId of path.child_paths) {
                const child = nodeMap.get(String(childId));
                if (child) {
                  expandNode(child);
                }
              }
            }
          }

          // –†–∞—Å–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –∫–æ—Ä–Ω–∏ (main query only)
          for (const root of allBestRoots) {
            expandNode(root);
          }

          const unincludedSubqueries = getUnincludedSubqueries();
          for (const root of unincludedSubqueries) {
            expandNode(root);
          }
        }

        function expandBestPlanOnly() {
          // –ü–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–∞–µ–º expanded
          expanded.clear();

          // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π –≤—ã–±–æ—Ä
          currentSelectedPathId = null;
          cy.elements('.selected-in-tree, .highlighted, .highlighted-edge')
            .removeClass('selected-in-tree highlighted highlighted-edge');

          // –†–∞—Å–∫—Ä—ã–≤–∞–µ–º –¢–û–õ–¨–ö–û —É–∑–ª—ã, –æ—Ç–Ω–æ—Å—è—â–∏–µ—Å—è –∫ –ª—É—á—à–µ–º—É –ø–ª–∞–Ω—É
          function expandNode(path) {
            if (!path) return;
            const subId = `subquery-${path._subKey}`;
            const levelId = `level-${path._levelKey}`;
            const bestRelsGroup = `best-rels-${levelId}`;
            const relId = `relation-${path._relKey}`;
            const bestPathsGroup = `best-paths-${relId}`;

            expanded.set(subId, true);
            expanded.set(levelId, true);
            expanded.set(bestRelsGroup, true);
            expanded.set(relId, true);
            expanded.set(bestPathsGroup, true);

            // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Ä–∞—Å–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ—Ö –ø–æ—Ç–æ–º–∫–æ–≤
            if (Array.isArray(path.child_paths)) {
              for (const childId of path.child_paths) {
                const child = nodeMap.get(String(childId));
                if (child) {
                  expandNode(child);
                }
              }
            }
          }

          for (const root of allBestRoots) {
            expandNode(root);
          }

          const unincludedSubqueries = getUnincludedSubqueries();
          for (const root of unincludedSubqueries) {
            expandNode(root);
          }

          // –û–±–Ω–æ–≤–ª—è–µ–º –≥—Ä–∞—Ñ
          refreshGraph();
        }
        expandBestPath();

        cy = cytoscape({
          container: document.getElementById('cy'),
          elements: [],
          style: [
            {
              selector: 'node.path-node',
              style: {
                'shape': 'rectangle',
                'background-color': '#e0e0e0',
                'label': 'data(label)',
                'text-valign': 'center',
                'text-halign': 'center',
                'color': '#000',
                'font-size': '10px',
                'text-wrap': 'wrap',
                'text-max-width': '80px',
                'width': '90px',
                'height': '50px',
                'border-width': 1,
                'border-color': '#999'
              }
            },
            {
            selector: 'node.path-group',
              style: {
                'shape': 'roundrectangle',
                'label': 'data(label)',
                'text-valign': 'top',
                'text-halign': 'right',
                'text-margin-x': '-8px',
                'text-margin-y': '4px',
                'color': '#000',
                'font-size': '11px',
                'font-weight': 'bold',
                'background-opacity': 0.15,
                'border-width': 1,
                'border-style': 'dashed',
                'border-color': '#666'
              }
            },
            {
              selector: 'node.level-group, node.relation-group, node.subquery-group',
              style: {
                'shape': 'roundrectangle',
                'label': 'data(label)',
                'text-valign': 'top',
                'text-halign': 'right',
                'text-margin-x': '-8px',
                'text-margin-y': '4px',
                'color': '#000',
                'font-size': '11px',
                'font-weight': 'bold',
                'background-opacity': 0.15
              }
            },
            {
              selector: 'node.level-group',
              style: {
                'border-width': 1,
                'border-style': 'solid',
                'border-color': '#c00'
              }
            },
            {
              selector: 'node.relation-group',
              style: {
                'background-opacity': 0.2,
                'border-width': 1,
                'border-style': 'dashed',
                'border-color': '#999'
              }
            },
            {
              selector: 'node.subquery-group',
              style: {
                'border-width': 2,
                'border-style': 'dotted',
                'border-color': '#666'
              }
            },
            {
              selector: 'edge',
              style: {
                'width': 1,
                'line-color': '#666',
                'target-arrow-shape': 'triangle',
                'target-arrow-color': '#666',
                'curve-style': 'bezier'
              }
            },
            {
              selector: 'edge.level-order-edge',
              style: {
                'width': 1,
                'line-color': '#aaa',
                'target-arrow-shape': 'none',
                'opacity': 0.5,
                'line-style': 'dotted'
              }
            },
            {
              selector: '.highlighted',
              style: {
                'background-color': '#ffcc00',
                'border-color': '#ff9900',
                'border-width': 2
              }
            },
            {
              selector: '.highlighted-edge',
              style: {
                'line-color': '#ff9900',
                'target-arrow-color': '#ff9900',
                'width': 2
              }
            },
            {
              selector: '.selected-in-tree',
              style: {
                'background-color': '#cce6ff',
                'border-color': '#3399ff',
                'border-width': 2
              }
            }
          ],
          layout: { name: 'null' }
        });

        refreshGraph();

        document.getElementById('reset-view').addEventListener('click', () => {
          cy.elements('.highlighted, .highlighted-edge').removeClass('highlighted highlighted-edge');
          cy.fit();
        });


        document.getElementById('collapse-all').addEventListener('click', () => {
          // –ü–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–∞–µ–º expanded -- –≤—Å—ë —Å–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è
          expanded.clear();
          // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É
          cy.elements('.highlighted, .highlighted-edge, .selected-in-tree')
            .removeClass('highlighted highlighted-edge selected-in-tree');
          currentSelectedPathId = null;
          // –û–±–Ω–æ–≤–ª—è–µ–º –≥—Ä–∞—Ñ
          refreshGraph();
        });

        document.getElementById('clear-filters').addEventListener('click', () => {
          relationFilters.clear();
          refreshGraph();
        });

        document.getElementById('expand-best').addEventListener('click', () => {
          expandBestPlanOnly();
        });
        document.getElementById('toggle-layout').addEventListener('click', () => {
          currentLayoutDirection = currentLayoutDirection === 'LR' ? 'TB' : 'LR';
          refreshGraph(); // –ø–µ—Ä–µ—Å—Ç—Ä–æ–∏—Ç –≥—Ä–∞—Ñ —Å –Ω–æ–≤—ã–º layout
        });

        document.getElementById('copy-selected-path').addEventListener('click', () => {
          if (!currentSelectedPathId) {
            alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å');
            return;
          }

          const selectedPath = nodeMap.get(currentSelectedPathId);
          if (!selectedPath) {
            alert('–í—ã–±—Ä–∞–Ω–Ω—ã–π –ø—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
            return;
          }

          // –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è: level, startup_cost*100, total_cost*100 (–≤—Å–µ –∫–∞–∫ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞)
          const level = selectedPath.level || 0;
          const totalCost = selectedPath.total_cost ? Math.round(parseFloat(selectedPath.total_cost) * 100) : 0;
          const startupCost = selectedPath.startup_cost ? Math.round(parseFloat(selectedPath.startup_cost) * 100) : 0;

          const pathInfo = `${level}, ${startupCost}, ${totalCost}`;

          // –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞
          navigator.clipboard.writeText(pathInfo)
            .then(() => {
              // –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
              const button = document.getElementById('copy-selected-path');
              const originalText = button.textContent;
              button.textContent = '–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!';

              setTimeout(() => {
                button.textContent = originalText;
              }, 2000);
            })
            .catch(err => {
              console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–∏: ', err);
              alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é: ' + err.message);
            });
        });

        cy.on('tap', 'node.subquery-group, node.level-group', function (evt) {
          const id = evt.target.id();
          if (expanded.has(id)) {
            expanded.delete(id);
          } else {
            expanded.set(id, true);
          }
          refreshGraph();
        });

        cy.on('tap', 'node.relation-group', function (evt) {
          const id = evt.target.id();
          const originalEvent = evt.originalEvent;
          const isFilterMode = originalEvent.ctrlKey || originalEvent.metaKey;

          // –üÔøΩÔøΩ–æ–ø—É—Å–∫–∞–µ–º, –µ—Å–ª–∏ —ç—Ç–æ –≥—Ä—É–ø–ø–æ–≤–æ–π —É–∑–µ–ª (best/other)
          if (id.startsWith('best-rels-') || id.startsWith('other-rels-')) {
            if (expanded.has(id)) {
              expanded.delete(id);
            } else {
              expanded.set(id, true);
            }
            refreshGraph();
            return;
          }

          if (isFilterMode) {
            const currentFilter = relationFilters.get(id) || '';
            const newFilter = prompt(
              '–§–∏–ª—å—Ç—Ä –ø–æ path_type (–æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –¥–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è):\n(–Ω–∞–ø—Ä–∏–º–µ—Ä: SeqScan, IndexScan, NestLoop)',
              currentFilter
            );

            if (newFilter !== null) {
              const trimmed = newFilter.trim();
              if (trimmed === '') {
                relationFilters.delete(id);
              } else {
                relationFilters.set(id, trimmed);
              }
              refreshGraph();
            }
          } else {
            // Toggle expansion for the relation node
            if (expanded.has(id)) {
              expanded.delete(id);
            } else {
              expanded.set(id, true);
            }
            refreshGraph();
          }
        });

        function collectDescendants(nodeId, visited = new Set()) {
          const idStr = String(nodeId);
          if (visited.has(idStr)) return visited;
          visited.add(idStr);
          const node = nodeMap.get(idStr);
          if (node && Array.isArray(node.child_paths)) {
            for (const child of node.child_paths) {
              collectDescendants(String(child), visited);
            }
          }
          return visited;
        }

        cy.on('tap', 'node.path-node', function (evt) {
          const nodeId = evt.target.id();

          // Clear all selections and highlights
          document.querySelectorAll('.path-line.selected').forEach(e => e.classList.remove('selected'));
          document.querySelectorAll('.path-line.child-highlight').forEach(e => e.classList.remove('child-highlight'));
          document.querySelectorAll('.selected-row').forEach(e => e.classList.remove('selected-row'));
          cy.elements('.selected-in-tree').removeClass('selected-in-tree');

          // Update the current selected path
          currentSelectedPathId = nodeId;

          // Highlight the clicked path node in the tree
          const node = cy.getElementById(nodeId);
          if (node.length > 0) {
            node.addClass('selected-in-tree');
          }

          // Highlight the corresponding line in the EXPLAIN panel
          const explainLine = document.querySelector(`.path-line[data-path-id="${nodeId}"]`);
          if (explainLine) {
            explainLine.classList.add('selected');
          }

          // Highlight the corresponding row in the table
          const tableRow = document.querySelector(`#table-wrapper tbody tr[data-path-id="${nodeId}"]`);
          if (tableRow) {
            tableRow.classList.add('selected-row');
          }

          // Highlight child nodes in EXPLAIN
          highlightChildNodesInExplain(nodeId);

          // Render the selected path with its children in the right panel
          renderSelectedPathWithChildren(nodeId);

          // Show the alternative paths table for the selected path
          const clickedPath = nodeMap.get(nodeId);
          if (clickedPath) {
            const relKey = clickedPath._relKey;
            const alternatives = Array.from(nodeMap.values()).filter(p => p._relKey === relKey);

            if (alternatives.length > 0) {
              // Switch to alternative paths table showing paths for this relation
              currentTableType = 'alternative-paths';

              // Update button states in the container
              const container = document.getElementById('empty-container');
              if (container) {
                container.querySelectorAll('.table-control-btn').forEach(b => {
                  b.classList.remove('active');
                });
                const altPathsBtn = container.querySelector('.table-control-btn[data-table-type="alternative-paths"]');
                if (altPathsBtn) {
                  altPathsBtn.classList.add('active');
                }
              }

              // Show alternative paths for this relation
              const subqueryId = clickedPath.subquery_id;
              const level = clickedPath.level;
              const relId = clickedPath.rel_id;
              showAlternativePathsForRelation(subqueryId, level, relId, relKey);

              // After the table is updated, highlight the clicked path row
              setTimeout(() => {
                const tableRow = document.querySelector(`#table-wrapper tbody tr[data-path-id="${nodeId}"]`);
                if (tableRow) {
                  // Remove any existing selections in the table
                  document.querySelectorAll('#table-wrapper tbody tr.selected-row').forEach(row => {
                    row.classList.remove('selected-row');
                  });
                  // Add selection to the current row
                  tableRow.classList.add('selected-row');
                }
              }, 10); // Small delay to ensure the table is rendered
            }
          }

          // Collect descendants for highlighting in the graph
          const descendants = collectDescendants(nodeId);
          cy.elements('.highlighted, .highlighted-edge').removeClass('highlighted highlighted-edge');

          descendants.forEach(id => {
            const el = cy.getElementById(id);
            if (el.length > 0) el.addClass('highlighted');
          });

          const descendantSet = new Set(descendants);
          cy.edges().forEach(edge => {
            const src = edge.source().id();
            if (descendantSet.has(src)) {
              edge.addClass('highlighted-edge');
            }
          });
        });

        cy.on('dblclick', 'node.path-node', function (evt) {
          const node = evt.target;

          cy.animate({
            center: {
              eles: node
            },
            zoom: 1.2,
            duration: 500
          });
        });

        cy.on('tap', 'node.path-group', function (evt) {
          const id = evt.target.id();
          if (expanded.has(id)) {
            expanded.delete(id);
          } else {
            expanded.set(id, true);
          }
          refreshGraph();
        });

        cy.on('tap', (evt) => {
          if (evt.target === cy) {
            cy.elements('.highlighted, .highlighted-edge').removeClass('highlighted highlighted-edge');
          }
        });

        makeResizable();
      })
      .catch(err => {
        console.error('Failed to load data.json:', err);
        alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ data.json: ' + err.message);
        document.getElementById('explain-best-container').textContent = '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö.';
      });

      // –ó–∞–∫—Ä—ã—Ç–∏–µ –º–µ–Ω—é —Å—Ç–æ–ª–±—Ü–æ–≤ –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ –µ–≥–æ
      document.addEventListener('click', function(e) {
        const btn = document.getElementById('toggle-columns-btn');
        const dropdown = document.getElementById('columns-dropdown');

        // –ï—Å–ª–∏ –º–µ–Ω—é —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –æ—Ç–∫—Ä—ã—Ç–æ
        if (dropdown && dropdown.style.display === 'block') {
          // –ï—Å–ª–∏ –∫–ª–∏–∫ –ù–ï –ø–æ –∫–Ω–æ–ø–∫–µ –∏ –ù–ï –ø–æ –º–µ–Ω—é -- –∑–∞–∫—Ä—ã—Ç—å
          if (!btn?.contains(e.target) && !dropdown.contains(e.target)) {
            dropdown.style.display = 'none';
          }
        }
      });
  </script>
</body>
</html>